<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>IndexedDB 60fps 영상 저장/삭제 데모</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b0c10;
      --fg: #eaeaea;
      --muted: #9aa0a6;
      --accent: #5c9dff;
      --card: #16181d;
      --border: #2a2f36;
      --danger: #ff6b6b;
      --warn: #f4b400;
      --ok: #34a853;
    }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg); color: var(--fg);
    }
    header, footer {
      padding: 16px 20px; border-bottom: 1px solid var(--border);
    }
    header h1 { margin: 0 0 8px; font-size: 20px; }
    header p { margin: 0; color: var(--muted); font-size: 13px; }
    main { padding: 16px 20px; display: grid; gap: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: 1fr; }
    @media (min-width: 900px) {
      .row { grid-template-columns: 1.1fr 1fr; align-items: start; }
    }
    .panel {
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: 12px;
      padding: 14px;
    }
    .panel h2 { margin: 0 0 10px; font-size: 16px; }
    .ctrls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button, label.btn {
      background: #1f232b; color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer; font-weight: 600; font-size: 14px;
    }
    button:hover, label.btn:hover { border-color: var(--accent); }
    button.primary { background: var(--accent); color: #0b0c10; border-color: transparent; }
    button.danger { background: var(--danger); color: #0b0c10; border-color: transparent; }
    button.warn { background: var(--warn); color: #0b0c10; border-color: transparent; }
    .muted { color: var(--muted); font-size: 13px; }
    video { width: 100%; max-height: 400px; border-radius: 12px; background: #000; }
    input[type="text"] {
      background: #0f1216; border: 1px solid var(--border); color: var(--fg);
      border-radius: 10px; padding: 10px 12px; min-width: 220px;
    }
    input[type="file"] { display: none; }
    .grid {
      display: grid; gap: 10px;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
    }
    .card {
      border: 1px solid var(--border); background: #101318; border-radius: 12px; padding: 12px;
      display: grid; gap: 10px;
    }
    .card video { max-height: 180px; }
    .meta { font-size: 13px; color: var(--muted); display: grid; gap: 4px; }
    .meta strong { color: var(--fg); }
    .space {
      display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--muted);
    }
    progress {
      width: 160px; height: 12px;
      accent-color: var(--accent);
      background: #0f1216; border: 1px solid var(--border); border-radius: 6px;
    }
    .row-tight { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .hint { font-size: 12px; color: var(--muted); }
    .badge { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #1f232b; border: 1px solid var(--border); }
    .right { margin-left: auto; }
  </style>
</head>
<body>
  <header>
    <h1>IndexedDB 60fps 영상 저장/삭제 데모</h1>
    <p>60fps로 녹화 → IndexedDB 저장 → 목록/재생/다운로드/개별삭제/전체삭제. 파일 가져오기 저장도 지원.</p>
  </header>

  <main>
    <section class="row">
      <div class="panel">
        <h2>카메라 미리보기 및 녹화</h2>
        <div class="ctrls">
          <button id="btnStart" class="primary">녹화 시작 (60fps 시도)</button>
          <button id="btnStop" disabled>녹화 중지</button>
          <span class="badge" id="recState">대기</span>
          <span class="right hint">미리보기는 카메라 실시간 스트림입니다</span>
        </div>
        <div style="margin:10px 0;">
          <video id="preview" autoplay playsinline muted></video>
        </div>

        <div class="row-tight">
          <input type="text" id="titleInput" placeholder="영상 제목 (선택)" />
          <span class="hint">녹화 종료 시 제목으로 저장됩니다</span>
        </div>

        <div class="row-tight" style="margin-top:8px;">
          <span class="hint">MIME:</span>
          <span class="badge" id="mimeBadge">감지 중…</span>
          <span class="hint">청크 주기:</span>
          <span class="badge" id="timesliceBadge">200ms</span>
        </div>
      </div>

      <div class="panel">
        <h2>저장 공간 및 파일 가져오기</h2>
        <div class="space" style="margin-bottom:8px;">
          <span>저장 용량</span>
          <progress id="quotaBar" value="0" max="1"></progress>
          <span id="quotaText" class="muted">-</span>
          <button id="btnRefreshQuota">새로고침</button>
        </div>

        <div class="ctrls" style="margin-top:8px;">
          <label class="btn">
            파일 가져와 저장
            <input id="filePicker" type="file" accept="video/*" />
          </label>
          <button id="btnClearAll" class="danger">전체 삭제</button>
        </div>
        <p class="hint" style="margin-top:8px;">
          큰 파일은 저장에 시간이 걸릴 수 있어요. 저장 후 아래 목록에 나타납니다.
        </p>
      </div>
    </section>

    <section class="panel">
      <h2>저장된 영상 목록</h2>
      <div id="list" class="grid"></div>
      <p id="emptyState" class="muted" style="display:none; margin-top:8px;">아직 저장된 영상이 없습니다.</p>
    </section>
  </main>

  <footer>
    <span class="hint">참고: 실제 60fps 달성 여부는 장치/브라우저/조명/부하에 따라 달라집니다.</span>
  </footer>

  <script>
    // ====== 유틸 ======
    const $ = (sel) => document.querySelector(sel);
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const nowISO = () => new Date().toISOString();

    function fmtBytes(bytes) {
      if (!bytes && bytes !== 0) return "-";
      const units = ["B","KB","MB","GB","TB"];
      let i = 0, v = bytes;
      while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
      return `${v.toFixed(v < 10 && i > 0 ? 1 : 0)} ${units[i]}`;
    }
    function fmtSec(sec) {
      sec = Math.max(0, Math.round(sec));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      return h > 0 ? `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}` : `${m}:${String(s).padStart(2,"0")}`;
    }

    // ====== IndexedDB 래퍼 ======
    const DB_NAME = "videoDB";
    const DB_VER  = 1;
    const STORE   = "videos";

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE)) {
            const os = db.createObjectStore(STORE, { keyPath: "id", autoIncrement: true });
            os.createIndex("createdAt", "createdAt");
            os.createIndex("title", "title", { unique: false });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function addVideo(record) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.oncomplete = () => resolve(record);
        tx.onerror = () => reject(tx.error);
        tx.objectStore(STORE).add(record);
      });
    }

    async function getAllVideos() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readonly");
        const req = tx.objectStore(STORE).getAll();
        req.onsuccess = () => resolve(req.result.sort((a, b) => b.id - a.id));
        req.onerror = () => reject(req.error);
      });
    }

    async function deleteVideo(id) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.objectStore(STORE).delete(id);
      });
    }

    async function clearAllVideos() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.objectStore(STORE).clear();
      });
    }

    // ====== 저장 용량 ======
    async function refreshQuota() {
      if (!navigator.storage?.estimate) {
        $("#quotaText").textContent = "지원되지 않음";
        $("#quotaBar").value = 0;
        return;
      }
      const { quota = 0, usage = 0 } = await navigator.storage.estimate();
      $("#quotaBar").max = quota || 1;
      $("#quotaBar").value = usage || 0;
      $("#quotaText").textContent = `${fmtBytes(usage)} / ${fmtBytes(quota)} 사용`;
    }

    // ====== 녹화 관련 ======
    let mediaStream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordStartAt = 0;
    let chosenMime = "";

    function pickSupportedMime() {
      const candidates = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm;codecs=vp09.00.10.08',
        'video/webm',
        'video/mp4;codecs=avc1.42E01E,mp4a.40.2', // 일부 브라우저는 MediaRecorder MP4 미지원
      ];
      return candidates.find(type => MediaRecorder.isTypeSupported(type)) || "";
    }

    async function startPreview() {
      if (mediaStream) return;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 60, max: 60 }, // 60fps 요청
          },
        });
        $("#preview").srcObject = mediaStream;
      } catch (err) {
        alert("카메라/마이크 접근 실패: " + err.message);
      }
    }

    function setRecState(text, color='') {
      const el = $("#recState");
      el.textContent = text;
      el.style.background = color || '#1f232b';
      el.style.color = color ? '#0b0c10' : '';
    }

    async function startRecording() {
      await startPreview();
      recordedChunks = [];
      chosenMime = pickSupportedMime();
      $("#mimeBadge").textContent = chosenMime || "지원 코덱 없음 → 기본값";

      try {
        mediaRecorder = new MediaRecorder(mediaStream, chosenMime ? { mimeType: chosenMime, videoBitsPerSecond: 8_000_000 } : { videoBitsPerSecond: 8_000_000 });
      } catch (err) {
        alert("MediaRecorder 초기화 실패: " + err.message);
        return;
      }

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstart = () => {
        recordStartAt = performance.now();
        setRecState("녹화중", "#34a853");
        $("#btnStart").disabled = true;
        $("#btnStop").disabled = false;
      };
      mediaRecorder.onstop = async () => {
        const blob = new Blob(recordedChunks, { type: chosenMime || "video/webm" });
        const durationSec = (performance.now() - recordStartAt) / 1000;
        const title = ($("#titleInput").value || "녹화 영상") + "";

        const record = {
          title,
          createdAt: nowISO(),
          duration: durationSec,
          size: blob.size,
          mime: blob.type,
          // Blob은 IndexedDB에 직접 저장 가능
          data: blob,
        };
        await addVideo(record);
        await renderList();
        await refreshQuota();

        setRecState("저장됨", "#5c9dff");
        $("#btnStart").disabled = false;
        $("#btnStop").disabled = true;
        $("#titleInput").value = "";
      };

      const TIMESLICE = 200; // ms 단위: 청크 수집 주기
      $("#timesliceBadge").textContent = TIMESLICE + "ms";
      mediaRecorder.start(TIMESLICE);
    }

    async function stopRecording() {
      if (!mediaRecorder || mediaRecorder.state !== "recording") return;
      mediaRecorder.stop();
    }

    // ====== 파일 가져오기 → IndexedDB 저장 ======
    async function importFile(file) {
      if (!file) return;
      const blob = file.slice(0, file.size, file.type || "video/webm");
      const record = {
        title: file.name || "가져온 영상",
        createdAt: nowISO(),
        duration: 0, // 알 수 없으면 0으로 두고, 재생 시 길이 추정 가능
        size: blob.size,
        mime: blob.type || "video/webm",
        data: blob,
      };
      await addVideo(record);
      await renderList();
      await refreshQuota();
    }

    // ====== 목록 그리기 ======
    async function renderList() {
      const list = $("#list");
      const empty = $("#emptyState");
      list.innerHTML = "";
      const items = await getAllVideos();
      empty.style.display = items.length ? "none" : "block";

      for (const rec of items) {
        const url = URL.createObjectURL(rec.data);
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
          <video src="${url}" controls playsinline></video>
          <div class="meta">
            <div><strong>${escapeHtml(rec.title || "제목 없음")}</strong></div>
            <div>저장일: ${new Date(rec.createdAt).toLocaleString()}</div>
            <div>길이: ${rec.duration ? fmtSec(rec.duration) : "알 수 없음"} · 크기: ${fmtBytes(rec.size)} · MIME: ${rec.mime || "-"}</div>
            <div>ID: ${rec.id}</div>
          </div>
          <div class="ctrls">
            <button data-act="play" data-id="${rec.id}">재생</button>
            <button data-act="download" data-id="${rec.id}">다운로드</button>
            <button class="warn" data-act="rename" data-id="${rec.id}">제목 변경</button>
            <button class="danger" data-act="delete" data-id="${rec.id}">삭제</button>
          </div>
        `;
        // 이벤트 바인딩
        card.querySelectorAll("button").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            const id = Number(btn.dataset.id);
            const act = btn.dataset.act;
            if (act === "play") {
              const v = card.querySelector("video");
              v.currentTime = 0;
              await v.play().catch(()=>{});
            } else if (act === "download") {
              const a = document.createElement("a");
              const filename = (rec.title || `video_${rec.id}`).replace(/[\\/:*?"<>|]/g, "_") + (mimeToExt(rec.mime));
              a.href = url;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              a.remove();
            } else if (act === "delete") {
              if (!confirm("이 영상을 삭제할까요?")) return;
              await deleteVideo(id);
              await renderList();
              await refreshQuota();
            } else if (act === "rename") {
              const newTitle = prompt("새 제목을 입력하세요", rec.title || "");
              if (newTitle == null) return;
              await renameVideo(id, newTitle);
              await renderList();
            }
          });
        });
        list.appendChild(card);

        // 사용 후 URL 해제 (비동기 안전 타이밍)
        setTimeout(() => URL.revokeObjectURL(url), 60_000);
      }
    }

    function mimeToExt(mime) {
      if (!mime) return ".webm";
      if (mime.includes("mp4")) return ".mp4";
      if (mime.includes("webm")) return ".webm";
      return ".bin";
    }

    function escapeHtml(s) {
      return (s || "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    async function renameVideo(id, newTitle) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        const store = tx.objectStore(STORE);
        const getReq = store.get(id);
        getReq.onsuccess = () => {
          const rec = getReq.result;
          if (!rec) { reject(new Error("Not found")); return; }
          rec.title = newTitle;
          store.put(rec);
        };
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // ====== 이벤트 연결 ======
    $("#btnStart").addEventListener("click", startRecording);
    $("#btnStop").addEventListener("click", stopRecording);
    $("#btnClearAll").addEventListener("click", async () => {
      if (!confirm("정말 모든 영상을 삭제할까요? 이 작업은 되돌릴 수 없습니다.")) return;
      await clearAllVideos();
      await renderList();
      await refreshQuota();
      setRecState("전체 삭제 완료");
    });
    $("#filePicker").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      await importFile(file);
      e.target.value = "";
    });
    $("#btnRefreshQuota").addEventListener("click", refreshQuota);

    // 초기화
    (async function init() {
      $("#mimeBadge").textContent = pickSupportedMime() || "감지 실패";
      await startPreview().catch(()=>{});
      await renderList();
      await refreshQuota();
    })();
  </script>
</body>
</html>
